// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: ticketBuyers.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addRaffleMinterNonce = `-- name: AddRaffleMinterNonce :exec
UPDATE ticketBuyers SET nonce = $2
WHERE wallet_address = $1
`

type AddRaffleMinterNonceParams struct {
	WalletAddress string
	Nonce         pgtype.Int2
}

func (q *Queries) AddRaffleMinterNonce(ctx context.Context, arg AddRaffleMinterNonceParams) error {
	_, err := q.db.Exec(ctx, addRaffleMinterNonce, arg.WalletAddress, arg.Nonce)
	return err
}

type CreateRaffleWinnersForTxParams struct {
	WalletAddress string
	Nonce         int16
}

const createTicketBuyer = `-- name: CreateTicketBuyer :exec
INSERT INTO ticketBuyers(wallet_address, nonce, num_tickets, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5)
`

type CreateTicketBuyerParams struct {
	WalletAddress string
	Nonce         pgtype.Int2
	NumTickets    int16
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
}

func (q *Queries) CreateTicketBuyer(ctx context.Context, arg CreateTicketBuyerParams) error {
	_, err := q.db.Exec(ctx, createTicketBuyer,
		arg.WalletAddress,
		arg.Nonce,
		arg.NumTickets,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const getAllTicketBuyers = `-- name: GetAllTicketBuyers :many
SELECT wallet_address, num_tickets FROM ticketBuyers
ORDER BY num_tickets ASC
`

type GetAllTicketBuyersRow struct {
	WalletAddress string
	NumTickets    int16
}

func (q *Queries) GetAllTicketBuyers(ctx context.Context) ([]GetAllTicketBuyersRow, error) {
	rows, err := q.db.Query(ctx, getAllTicketBuyers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTicketBuyersRow
	for rows.Next() {
		var i GetAllTicketBuyersRow
		if err := rows.Scan(&i.WalletAddress, &i.NumTickets); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumTickets = `-- name: GetNumTickets :one
SELECT num_tickets FROM ticketBuyers
WHERE wallet_address = $1
`

func (q *Queries) GetNumTickets(ctx context.Context, walletAddress string) (int16, error) {
	row := q.db.QueryRow(ctx, getNumTickets, walletAddress)
	var num_tickets int16
	err := row.Scan(&num_tickets)
	return num_tickets, err
}

const getTicketBuyer = `-- name: GetTicketBuyer :one
SELECT wallet_address, nonce, num_tickets, created_at, updated_at FROM ticketBuyers
WHERE wallet_address = $1
`

func (q *Queries) GetTicketBuyer(ctx context.Context, walletAddress string) (Ticketbuyer, error) {
	row := q.db.QueryRow(ctx, getTicketBuyer, walletAddress)
	var i Ticketbuyer
	err := row.Scan(
		&i.WalletAddress,
		&i.Nonce,
		&i.NumTickets,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUniqueWeights = `-- name: GetUniqueWeights :many
SELECT DISTINCT num_tickets FROM ticketBuyers
ORDER BY num_tickets ASC
`

func (q *Queries) GetUniqueWeights(ctx context.Context) ([]int16, error) {
	rows, err := q.db.Query(ctx, getUniqueWeights)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int16
	for rows.Next() {
		var num_tickets int16
		if err := rows.Scan(&num_tickets); err != nil {
			return nil, err
		}
		items = append(items, num_tickets)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNumTickets = `-- name: UpdateNumTickets :exec
UPDATE ticketBuyers SET num_tickets = $2, updated_at = $3
WHERE wallet_address = $1
`

type UpdateNumTicketsParams struct {
	WalletAddress string
	NumTickets    int16
	UpdatedAt     pgtype.Timestamp
}

func (q *Queries) UpdateNumTickets(ctx context.Context, arg UpdateNumTicketsParams) error {
	_, err := q.db.Exec(ctx, updateNumTickets, arg.WalletAddress, arg.NumTickets, arg.UpdatedAt)
	return err
}

const updateTicketBuyersNonceForTx = `-- name: UpdateTicketBuyersNonceForTx :exec
UPDATE ticketBuyers SET nonce = raffleWinners.nonce
FROM raffleWinners
WHERE ticketBuyers.wallet_address = raffleWinners.wallet_address
`

func (q *Queries) UpdateTicketBuyersNonceForTx(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateTicketBuyersNonceForTx)
	return err
}
